# Animator Model
# Andrew Tu
# Feb 23, 2018

## Design Overview
I developed my implementation in a top down approach, starting with the most general interfaces, and
working my way down as necessary. From the demo description, certain necessary functions and features
could be established.

```
Create red rectangle R with corner at (200,200), width 50 and height 100
Create blue oval C with center at (500,100), radius 60 and 30

R appears at time t=1 and disappears at time t=100
C appears at time t=6 and disappears at time t=100

R moves from (200,200) to (300,300) from time t=10 to t=50
C moves from (500,100) to (500,400) from time t=20 to t=70
C changes from blue to green from time t=50 to t=80
R moves from (300,300) to (200,200) from time t=70 to t=100
R changes width from 50 to 25 from time t=51 to t=70
```

The first two lines indicated the need of for someway to create a shape with 4 pieces of information.
1. Shape name
2. Shape position
3. Shape dimensions
4. Shape color

This led me to create a shape class that represented the data needed to create a shape. This also meant
we needed a function to add a shape to our animator.model, hence the creation of the `addShape` method.

Given that a user can add a shape to the animator.model, it also seemed natural to give the user the ability
to remove the shape from the animator.model. Thus, I also added a `deleteShape` method to the animator.model interface.

The remaining lines of the description yielded a number of important characteristics, there existed
a number of defined animations that had some effect on a particular shape. Furthermore, animations
acted upon a single shape and there could only be a single animation of particular type acting on a
shape at any point in time. Most importantly, animations are functions of time: the representation
of a given shape is dependent on the animations applied to the shape at a particular point in time.

From these lines, I added the `addAnimation` method that applies an a given animation to a particular
shape name.

The `toString` methods return the textual representation of the animator where an optional
time parameter can be given to see the state of the animator as a function of time.

Since the animator.model will be used to supply information to the view, I also wanted to provide an easy to
use, machine readable version of the state. Therefore, I included a `getState(float time)` method that
returned a List of shapes representing every state in the animator.model at a given time.

Finally, as a convenience function to the user, I exposed a `listShapes()` method which simply returned
a list of the shapes (names) in the animator.model. This

## IAnimatedShape
While implementing the `addAnimation` function for the animator.model, it became apparent that there needed to be a
distinction between a shape's representation at a discrete point in time, and the shapes representation as a
function of time. Thus, I created an IAnimatedShape class which represents the shape as a function of time.
This interface exposes the ability to add animations to a particular shape and then get the state of the shape
back as at a particular time. We also wanted to see all animations that would occur over the course of the run
time for the shape so I implemented a `getSummary()` function that was responsible for returning a list of
animation summaries (an animation summary being a tuple of time and descriptions that implements the comparable
class allowing summaries to be sorted by start time).

## IShape
Where `IAnimatedShape` represented the state over time, IShape represents the shape at a discrete point in
time. The shape interface requires certain functions for accessing color, dimensions, and position.
One of the tricky aspects of shapes is that reference points and dimension are unique to the type of shape
- therefore enums/interfaces were established to represent each respectively.

## Rectangle
The rectangle represents a concrete implementation of a shape. In the interest of time, I only
implemented a rectangle, however, due to the abstract shape representations, implementation additonal
shapes is easily done.

## Abstract Classes and Factories
Where applicable, abstract classes were implemented to abstract common functions out of concrete classes.
Where applicable, factories were created to avoid locking classes into concrete implementations.


## Other Notes:
This code needs some refactoring which I was not able to do in time for submission. A number
of tests are also failing with a "NotImplementedException" due to the nature of not having been
implemented. I posted twice in the Piazza regarding how to handle tests that have written but are not
(and cannot) be passed or fully written since we do not know how they are supposed to behave.
